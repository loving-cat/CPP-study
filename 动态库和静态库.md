# 动态库和静态库

Linux 		.so（动态库）  	.a（静态库） 

Windows：	.dll 			.lib

---

## NO1:		

**静态库			动态库----动态库 编译和使用特点---gcc/g++**

**怎么办？**

- a.怎么做库(开发角度)	   	a.怎么做库(开发角度)

- b.怎么用库(使用角度)                   b.怎么用库(使用角度)

**是什么？**

所谓库文件，本质，就是把.o打包 ar-rc |  所谓库文件，本质，就是把.o打包-fPIC

​									gcc,g++ -shared  

**为什么？**    

​	提高开发效率

![image-20240513172141301](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240513172141301.png)

**ar rc[replace and create]命令 ---- 是gnu归档工具**

静态库调用

![image-20240513173114669](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240513173114669.png)



**动态库**，因为动态库要在程序运行的时候，要找到动态库加载并运行！

﻿**静态库**为什么没有这个问题？ 编译期间，已经将库中的代码拷贝到我们的可执行程序内部了！加载和库就没有关系了！

**库文件名称和引入库的名称** 

**如：libc.so -> c库，去掉前缀lib，去掉后缀.so,.a**

---

## **为了让程序动态的找到动态库有下面几种方法**

- ﻿a.安装到系统

- ﻿b.建立软连接

- ﻿c.命令行导入环境变量

- ﻿d.修改.bashrc配置文件，让环境变量永久生效

- ﻿e.／etc/ld.so.conf.d 新增动态库搜索的配置文件，ldconfig

---

gcc 在不适用 static 选项的时候，默认使用动态库

﻿默认连接的是动态库

﻿如果你没有使用 －static，并且只提供.a，只能静态连接当前的.a库，其他库正常动态连接

﻿－static的意义是什么呢？ 必须强制的将我们的程序进行静态连接，这就要求我们连接的任何库都必须提供对应的静态库版本！

---

## **附加问题：动态库加载---可执行程序和地址空间-->不考虑静态库**

动态库在加载之后，要映射到当前进程的堆栈之间的共享区

动态库也叫做共享库

![image-20240514163903023](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514163903023.png)

---

**我们的可执行程序，编译成功，没有加载运行，二进制代码中有"地址"吗？**

​	答：有地址，可执行程序，默认形成的时候，内部就包含了地址--->我们直接看源代码，不用加载运行，我们可以在我们的大脑中运行这个程序。

​	我们一般在Linux中形成的可执行程序，格式为<span style="color: #FFC0C0;">ELF</span>

<span style="color: #FFC0C0;">**ELF格式的可执行程序，二进程是有自己的固定格式的。ELF可执行程序的头部，可执行程序的属性**</span>

<span style="color: #FFC0C0;">**可执行程序编译之后，会变成很多行汇编语句，每条汇编语句都有他的地址**</span>

如何编址的呢？从00000.0000 ~ FFF....FFFFF---就是虚拟[逻辑]地址！！ [从全0到全F的绝对编址方式被称为<span style="color: #FFC0C0;">平坦模式</span>]

**严格意义上说下图中的编址方式且没被加载的磁盘上的可执行程序被叫做逻辑地址，程序还没加载的时候已经有了虚拟地址的概念了**

地址种类

![image-20240514170811116](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514170811116.png)

**ELF+加载器：可以找到文件各个区域的起始和结束地址,main函数的入口地址**

---

**进程=内核数据结构+代码数据**

![image-20240514172411229](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514172411229.png)

如果mm_struct 是结构体对象，成员变量呢？

code_start,code_end,global_start....

**初始值从哪里来呢？？？ --->从可执行程序中来！！！--->虚拟地址空间概念，不是OS独有的，而是，要有OS，编译器，加载器。**

当程序加载的时候，每行代码在内存当中都需要有它自己的一个物理地址

![image-20240514173044146](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514173044146.png)

<span style="color:red">每行代码既会有自己的虚拟地址，又有物理地址</span>

## **CPU内存在一个寄存器---> PC指针**

**它会保存当前正在执行指令的下一条指令的地址--pc指向哪里，CPU就去执行那里的代码**

在Linux操作系统中，CPU的程序计数器（Program Counter，简称PC）指针是一个寄存器，它存储着下一条将要执行的指令的地址。程序计数器是CPU内部的一个寄存器，用于控制程序的执行流程。

### Linux中CPU的PC指针的一些要点：

1. **寄存器**：PC指针是一个特殊的寄存器，通常在x86架构中被称为`eip`（Instruction Pointer），而在x86-64架构中被称为`rip`（Instruction Pointer）。

2. **指令执行**：每执行完一条指令后，PC指针会自动更新为下一条指令的地址，或者在跳转指令执行后更新为跳转到的目标地址。

3. **上下文切换**：在进程上下文切换时，操作系统会保存当前进程的PC指针到进程控制块（Process Control Block，PCB）中，并加载下一个要执行的进程的PC指针。

4. **调试**：在调试Linux程序时，PC指针的值可以帮助开发者确定程序执行的位置。使用调试器（如gdb）时，可以查看和修改PC指针的值。

5. **系统调用**：当程序执行系统调用时，PC指针会指向引发系统调用的那条指令。在系统调用完成后，操作系统会恢复程序的PC指针，以便程序能够继续执行下一条指令。

6. **异常和中断处理**：当CPU接收到异常或中断信号时，会将当前的PC指针保存，并跳转到相应的处理程序。

7. **寄存器窗口**：在某些架构中，如SPARC，PC指针可能不是直接存储指令的地址，而是存储指令的偏移量，这是因为它们使用了寄存器窗口技术。

8. **虚拟内存**：现代操作系统使用虚拟内存，因此PC指针中存储的是**虚拟地址**，操作系统负责将**虚拟地址转换为物理地址**。

要查看或操作PC指针，通常需要特定的系统级工具或调试器，因为这通常涉及对底层硬件的操作。在用户态程序中，直接操作PC指针是不可能的，因为这会导致系统不稳定。

### **虚拟地址构建页表的左侧，物理地址构建页表的右侧---页表映射关系的建立**

![image-20240514181917614](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514181917614.png)

![image-20240514182903706](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514182903706.png)

1. 进程创建阶段，初始化地址空间，让CPU知道main函数入口地址
2. 加载->每一行代码和数据，就都有了物理地址，自己的虚拟地址自己也知道，然后就可以构建映射了

库被映射到虚拟地址空间的什么位置，重要吗，影响吗？

​	答：不影响，不重要，只要加载完了，虚拟地址可以一直变化

库函数调用，其实也是在我的地址空间返回内来回跳转

库有没有加载？你怎么知道一个库没有加载呢？

​	答:OS可以让进程知道！库也要先描述，在组织，被OS管理！

![image-20240514181110130](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240514181110130.png)