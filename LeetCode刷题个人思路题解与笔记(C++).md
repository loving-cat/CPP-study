[136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/single-number/description/)
é¢˜ç›®ï¼š

ç»™å®šä¸€ä¸ªéç©ºæ•´æ•°æ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚
è¯´æ˜ï¼š
ä½ çš„ç®—æ³•åº”è¯¥å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚ä½ å¯ä»¥ä¸ä½¿ç”¨é¢å¤–ç©ºé—´æ¥å®ç°å—ï¼Ÿ

æ˜¾ç„¶ï¼Œè¿™ä¸€é¢˜æ˜¯ä»Šå¤©é¢˜ç›®çš„ç®€åŒ–ç‰ˆã€‚åœ¨ä¸€å †æˆå¯¹çš„æ•°å­—ä¸­æ‰¾ä¸€ä¸ªè½å•çš„ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å¼‚æˆ–è¿ç®—ã€‚

ç†ç”±æ˜¯ï¼š

1.ä¸¤ä¸ªç›¸åŒæ•°å­—åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä¸º0ã€‚è¿™ä¸ªç»“æœå¯ä»¥å¸®æˆ‘ä»¬æ’é™¤æ‰æˆå¯¹çš„æ•°å­—ï¼›
2.0å’Œä»»ä½•æ•°å­—è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œéƒ½å¾—åˆ°è¿™ä¸ªæ•°å­—æœ¬èº«ã€‚
æ‰€ä»¥ï¼Œåªè¦å¯¹numsä¸­çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œå¼‚æˆ–ï¼Œå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆã€‚

ä»£ç ï¼š

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) { // å¼‚æˆ–è¿ç®—ï¼Œå¯¹æ‰€æœ‰è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œæœ€ç»ˆå¾—åˆ°çš„å°±æ˜¯ç»“æœã€‚
        int res = 0;
        for (auto num: nums) 
            res ^= num;
        return res;
    }
};
```

[137. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/single-number-ii/description/)
ä»Šå¤©çš„é¢˜ç›®å’Œå‰‘æŒ‡ Offer 56 - II. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° IIæ˜¯ä¸€æ ·çš„ã€‚å¦‚æœå¤§å®¶æ²¡æœ‰ã€Šå‰‘æŒ‡offer ç¬¬äºŒç‰ˆã€‹çš„ç”µå­ç‰ˆï¼Œå¯ä»¥ç‚¹å‡»è¿™é‡Œä¸‹è½½ã€‚

ä»ä¸Šé¢ä¸€é¢˜å¯ä»¥å¾—åˆ°ä½è¿ç®—çš„æ€è·¯ã€‚ä½†æ˜¯å¦‚æœè¿˜æ˜¯ä»…ä»…ä½¿ç”¨å¼‚æˆ–è¿ç®—ï¼Œæˆ‘ä»¬ä¼šå‘ç°å¯¸æ­¥éš¾è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™é“é¢˜è™½ç„¶å’Œä¸Šé¢çš„é¢˜ç›®å¾ˆåƒï¼Œä½†æ–¹æ³•ä¸Šé¢ä¸èƒ½ç®€å•åœ°è¿›è¡Œæ‰¿æ¥ã€‚ï¼ˆToo Sad~o(â•¥ï¹â•¥)oï¼‰

æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œæˆ–è®¸å¯ä»¥è€ƒè™‘ä»æ¯ä¸ªå…ƒç´ éƒ½å‡ºç°ä¸‰æ¬¡å…¥æ‰‹ã€‚å¦‚æœä»æ¬¡æ•°å…¥æ‰‹ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°èƒ½ä¸èƒ½å’Œä»€ä¹ˆä¸œè¥¿æ•´é™¤3æŒ‚é’©ã€‚å› ä¸ºé™¤äº†æŸä¸ªå…ƒç´ ï¼Œå…¶ä»–å…ƒç´ éƒ½æ˜¯ä¸‰ä¸ªä¸‰ä¸ªä¸ºä¸€ç»„çš„ã€‚

æˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼š-2^31 <= nums[i] <= 2^31 - 1ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¤„ç†çš„æ•°æ®éƒ½æ˜¯32ä½çš„æ•°æ®ã€‚å¦‚æœæŠŠæ¯ä¸€ä¸ªæ•°å­—éƒ½çœ‹æˆäºŒè¿›åˆ¶ï¼Œé‚£ä¹ˆä¸€ä¸ªåè¿›åˆ¶æ•°nums[i]å¯¹åº”ä¸€ä¸ª32ä½çš„äºŒè¿›åˆ¶æ•°ã€‚å°†æ‰€æœ‰nums[i]å¯¹åº”çš„äºŒè¿›åˆ¶æ•°çš„å¯¹åº”ä½æ±‚å’Œï¼Œå°†æ¯ä¸€å¯¹åº”ä½çš„å’Œå€¼ä¸3è¿›è¡Œå–æ¨¡è¿ç®—ï¼Œå¾—åˆ°çš„ä½™æ•°å°±æ˜¯ç­”æ¡ˆçš„å¯¹åº”äºŒè¿›åˆ¶ä½çš„æ•°å€¼ã€‚è¿™æ˜¯å› ä¸ºé™¤äº†ç­”æ¡ˆæœ¬èº«ï¼Œå…¶å®ƒå…ƒç´ éƒ½æ˜¯ä¸‰ä¸ªä¸‰ä¸ªä¸ºä¸€ç»„çš„ã€‚

ä¸Šé¢çš„è¯­è¨€æœ‰äº›æŠ½è±¡ï¼Œæˆ‘ä»¬ä¸¾ä¸ªä¾‹å­ï¼š

å¦‚æœè¾“å…¥æ˜¯ï¼šnums = [2,2,3,2]ï¼Œé‚£ä¹ˆå®ƒçš„å„ä¸ªå…ƒç´ å¯¹åº”çš„32ä½äºŒè¿›åˆ¶æ•°å°±æ˜¯[00000000000000000000000000000010, 

 00000000000000000000000000000010, 

 00000000000000000000000000000011, 

 00000000000000000000000000000010]ï¼›
æ¥ç€ï¼Œå¯¹è¿™äº›äºŒè¿›åˆ¶æ•°çš„å¯¹åº”ä½è¿›è¡Œæ±‚å’Œï¼Œå¾—åˆ°ï¼š[00000000000000000000000000000041]ï¼›
å¯¹è¿™ä¸ªæ±‚å’Œç»“æœçš„æ¯ä¸€ä½è¿›è¡Œ3çš„å–æ¨¡è¿ç®—ï¼Œå¾—åˆ°ï¼š[00000000000000000000000000000011]ï¼›
æŠŠä¸Šé¢çš„ç»“æœä»äºŒè¿›åˆ¶è½¬æ¢ä¸ºåè¿›åˆ¶ï¼Œå°±æ˜¯ï¼š3ã€‚è¿™å°±æ˜¯æˆ‘ä»¬çš„ç­”æ¡ˆã€‚
ä»£ç ï¼š

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < 32; i++) { // å› ä¸ºnums[i]æ˜¯32ä½æ•´æ•°ï¼Œ
        // æ‰€ä»¥é’ˆå¯¹æ¯ä¸€ä½çš„å¯¹åº”äºŒè¿›åˆ¶æ•°å€¼æ±‚å’Œ
            int sum = 0;
            for (int num : nums) {//ï¼ˆnum>>iï¼‰&1 æå–æœ€åä¸€ä½
                sum += ((num >> i) & 1); // æå–ä»å³å¾€å·¦æ•°ç¬¬iä½çš„æ•°å€¼ï¼Œå°†æ‰€æœ‰nums[i]
                // äºŒè¿›åˆ¶ä¸‹çš„ç¬¬iä½æ•°å€¼è¿›è¡Œæ±‚å’Œ
            }
            if (sum % 3 == 1) { // å¦‚æœæ²¡åŠæ³•è¢«3æ•´é™¤ï¼Œé‚£ä¹ˆè¯´æ˜è½å•çš„é‚£ä¸ªæ•°çš„ç¬¬iä½æ˜¯1ä¸æ˜¯0
                res |= (1 << i);//æŒ‰ä½æˆ–ç­‰ï¼Œä¸€è¾¹ä¸º1åˆ™å…¨ä¸º1ï¼Œå…¨ä¸º1åˆ™ä¸º0
            }
        }
        return res; // è¾“å‡ºç»“æœ
    }
};

```

[260. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/single-number-iii/description/)
é¢˜ç›®ï¼š

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œå…¶ä¸­æ°å¥½æœ‰ä¸¤ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ï¼Œå…¶ä½™æ‰€æœ‰å…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚ æ‰¾å‡ºåªå‡ºç°ä¸€æ¬¡çš„é‚£ä¸¤ä¸ªå…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚
è¿›é˜¶ï¼šä½ çš„ç®—æ³•åº”è¯¥å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚ä½ èƒ½å¦ä»…ä½¿ç”¨å¸¸æ•°ç©ºé—´å¤æ‚åº¦æ¥å®ç°ï¼Ÿ

ç¤ºä¾‹ï¼š

è¾“å…¥ï¼šnums = [1,2,1,3,2,5]
è¾“å‡ºï¼š[3,5]
è§£é‡Šï¼š[5, 3] ä¹Ÿæ˜¯æœ‰æ•ˆçš„ç­”æ¡ˆã€‚

æœ¬é¢˜ä¸­ï¼Œæ¬¡æ•°å›å½’åˆ°ä¸€å¼€å§‹çš„ä¸¤æ¬¡ï¼Œä½†æ˜¯æ¯”è¾ƒè°ƒçš®çš„æ˜¯ï¼Œè½å•çš„å…ƒç´ ä¸æ­¢ä¸€ä¸ªã€‚

å·²ç»å†™è¿‡çš„ä¸Šé¢ä¸¤é“é¢˜ç›®ï¼Œå¯¹è¿™é“é¢˜å¯ä»¥å¸¦æ¥ä»€ä¹ˆæ ·çš„å¯å‘ï¼Ÿ

å¯å‘ä¸€ï¼šåº”è¯¥å¯ä»¥å°è¯•å¼‚æˆ–è¿ç®—ï¼Œå› ä¸ºå…ƒç´ å‡ºç°çš„é¢‘æ¬¡å˜æˆäº†2ï¼›
å¯å‘äºŒï¼šæ˜¾ç„¶åšä¸€æ¬¡å¼‚æˆ–è¿ç®—ä¸èƒ½å¾—åˆ°ç»“æœï¼Œåœ¨ä¸€æ¬¡å¼‚æˆ–è¿ç®—çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æ•ˆä»¿åŠ›æ‰£137. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIï¼Œå¯¹å¼‚æˆ–ä¹‹åçš„ç»“æœçš„äºŒè¿›åˆ¶ä½è¿›è¡Œåˆ†æå¤„ç†ã€‚
æˆ‘ä»¬çš„æ ¸å¿ƒæ€æƒ³è¿˜æ˜¯ä½¿ç”¨å¼‚æˆ–è¿ç®—ï¼Œä½†å¯¹äºä¸¤ä¸ªè½å•çš„å…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦æƒ³åˆ°ä¸€ä¸ªåˆ†ç±»æ³•åˆ™ï¼Œè®©å®ƒä»¬ä¿©åˆ†æ¥ã€‚å¯¹äºå®ƒä»¬ä¿©æ‰€åœ¨çš„ä¸¤ä¸ªåˆ†ç»„ï¼Œåˆ†åˆ«è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆã€‚

ä¸‹é¢æ˜¯åˆ†ç±»æ–¹æ³•çš„è®¾è®¡ï¼Œæˆ‘ä»¬ä¸¾ä¸€ä¸ªä¾‹å­çœ‹çœ‹ï¼š

å¯¹äº
$$
nums = [1,2,1,3,2,5]
$$
ï¼Œ

è½¬ä¸ºäºŒè¿›åˆ¶ä¸ºï¼š
$$
[0001, 0010, 0001, 0011, 0010, 0101];
$$
è¿›è¡Œå¼‚æˆ–ï¼Œå¾—åˆ°ç»“æœï¼š
$$
0110ï¼›
$$
é’ˆå¯¹ä¸Šé¢çš„ç»“æœï¼Œå‘ç°ä»å³å¾€å·¦æ•°ï¼ˆä»0å¼€å§‹ï¼‰ç¬¬1ä½ä¸Šï¼Œä¸¤ä¸ªè½å•çš„æ•°å­—æ˜¯ä¸åŒçš„ã€‚æˆ‘ä»¬å¯ä»¥æŠŠæ•°ç»„numsä¸­çš„æ•°å€¼è¿›è¡Œåˆ†ç»„ï¼Œåˆ†ç»„ä¾æ®å°±æ˜¯å„ä¸ªæ•°å€¼nums[i]çš„ç¬¬1ä½æ˜¯å¦ä¸º0ã€‚è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸¤ä¸ªè½å•çš„æ•°å€¼åˆ†åˆ°ä¸åŒçš„ç»„é‡Œé¢ã€‚åœ¨ä¸åŒç»„é‡Œé¢ï¼Œæˆ‘ä»¬ä½¿ç”¨å¼‚æˆ–è¿ç®—å³å¯ã€‚æˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªä¸åŒçš„ä½æ•°æå–å‡ºæ¥ï¼š0010ï¼›
å°†[1,2,1,3,2,5]é€ä¸ªå’Œ0010è¿›è¡Œä¸è¿ç®—ï¼Œè¿›è¡Œâ€œåˆ†ç»„â€ã€‚ä¹‹åå¯¹æ¯ä¸€ä¸ªâ€œåˆ†ç»„â€ä¸­çš„å…ƒç´ è¿›è¡Œå¼‚æˆ–è¿ç®—å³å¯ã€‚
**ä»£ç ï¼š**

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int group1 = 0, group2 = 0;
        int diff = 0, bit = 1;
        for (int num : nums) // å¼‚æˆ–è¿ç®—ï¼Œç›®çš„æ˜¯æ‰¾åˆ°ä¸¤ä¸ªè½å•æ•°å€¼çš„ä¸åŒï¼Œä¾¿äºåé¢åˆ†ç±»
            diff ^= num;
        while ((diff & bit) == 0) //  å·¦ç§»è¿ç®—ï¼Œæ‰¾åˆ°äºŒè€…æŸä¸€ä½çš„ä¸åŒï¼Œå°†è¿™ä¸€ä½å®šä¸ºåˆ†ç±»ä¾æ®
            bit <<= 1;
        for (int num : nums) { // å¯¹å…ƒç´ è¿›è¡Œéå†    
            if(num & bit) group1 ^= num; // å¯¹äºnumï¼Œå¦‚æœå¯¹äºbitä¸º1ï¼Œåˆ†ç±»ä¸ºgroup1ï¼Œå¯¹è¿™ä¸ª
            // groupè¿›è¡Œå¼‚æˆ–ï¼Œå¯ä»¥æ‰¾åˆ°è½å•çš„æ•°å€¼
            else group2 ^= num; // å¦‚æœnumçš„bitå¯¹åº”çš„æ˜¯0ï¼Œé‚£ä¹ˆå¼‚æˆ–æ‰¾åˆ°å¦ä¸€ä¸ªè½å•çš„æ•°å€¼
        }
        return vector<int> {group1, group2};   // è¿”å›ç»“æœ
    }
};
```

[88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode.cn/problems/merge-sorted-array/)

ç»™ä½ ä¸¤ä¸ªæŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2`ï¼Œå¦æœ‰ä¸¤ä¸ªæ•´æ•° `m` å’Œ `n` ï¼Œåˆ†åˆ«è¡¨ç¤º `nums1` å’Œ `nums2` ä¸­çš„å…ƒç´ æ•°ç›®ã€‚

è¯·ä½  **åˆå¹¶** `nums2` åˆ° `nums1` ä¸­ï¼Œä½¿åˆå¹¶åçš„æ•°ç»„åŒæ ·æŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—ã€‚

**æ³¨æ„ï¼š**æœ€ç»ˆï¼Œåˆå¹¶åæ•°ç»„ä¸åº”ç”±å‡½æ•°è¿”å›ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨æ•°ç»„ `nums1` ä¸­ã€‚ä¸ºäº†åº”å¯¹è¿™ç§æƒ…å†µï¼Œ`nums1` çš„åˆå§‹é•¿åº¦ä¸º `m + n`ï¼Œå…¶ä¸­å‰ `m` ä¸ªå…ƒç´ è¡¨ç¤ºåº”åˆå¹¶çš„å…ƒç´ ï¼Œå `n` ä¸ªå…ƒç´ ä¸º `0` ï¼Œåº”å¿½ç•¥ã€‚`nums2` çš„é•¿åº¦ä¸º `n` 

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
è¾“å‡ºï¼š[1,2,2,3,5,6]
è§£é‡Šï¼šéœ€è¦åˆå¹¶ [1,2,3] å’Œ [2,5,6] ã€‚
åˆå¹¶ç»“æœæ˜¯ [1,2,2,3,5,6] ï¼Œå…¶ä¸­æ–œä½“åŠ ç²—æ ‡æ³¨çš„ä¸º nums1 ä¸­çš„å…ƒç´ ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums1 = [1], m = 1, nums2 = [], n = 0
è¾“å‡ºï¼š[1]
è§£é‡Šï¼šéœ€è¦åˆå¹¶ [1] å’Œ [] ã€‚
åˆå¹¶ç»“æœæ˜¯ [1] ã€‚
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šnums1 = [0], m = 0, nums2 = [1], n = 1
è¾“å‡ºï¼š[1]
è§£é‡Šï¼šéœ€è¦åˆå¹¶çš„æ•°ç»„æ˜¯ [] å’Œ [1] ã€‚
åˆå¹¶ç»“æœæ˜¯ [1] ã€‚
æ³¨æ„ï¼Œå› ä¸º m = 0 ï¼Œæ‰€ä»¥ nums1 ä¸­æ²¡æœ‰å…ƒç´ ã€‚nums1 ä¸­ä»…å­˜çš„ 0 ä»…ä»…æ˜¯ä¸ºäº†ç¡®ä¿åˆå¹¶ç»“æœå¯ä»¥é¡ºåˆ©å­˜æ”¾åˆ° nums1 ä¸­ã€‚
```

**æç¤ºï¼š**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- -10^9 <= nums1[i], nums2[j] <= 10^

**è¿›é˜¶ï¼š**ä½ å¯ä»¥è®¾è®¡å®ç°ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(m + n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ

```c++
class Solution{
    pubilc:
    	void merge(vector<int>& nums1,int m,vector<int>& nums2,int n)
        {
            //æ€è·¯ï¼š
            //æœ¬ä½“ä½¿ç”¨åŒæŒ‡é’ˆ,pæŒ‡å‘nums1ï¼ŒqæŒ‡å‘nums2
            int p=0,q = 0;
            //åˆ›å»ºä¸€ä¸ªä¸´æ—¶å˜é‡æ–¹ä¾¿æ‹¿åˆ°ä¸¤ä¸ªæ•°ç»„å†…çš„å€¼
            int tmp = 0;
            //åˆ›å»ºç¬¬ä¸‰ä¸ªæ•°ç»„æ‹¿åˆ°å€¼
            int sorted[m+n] = 0;
            //å¾ªç¯ï¼Œå½“på¤§äºmæ—¶ï¼Œè¡¨æ˜å·²ç»éå†å®Œnums1æ•°ç»„ï¼Œå½“qå¤§äºnæ—¶ï¼Œä»£è¡¨å·²ç»éå†å®Œnums2
            while(p < m || q < n)
            {
                //ç¬¬ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ï¼Œå¯ä»¥å‡è®¾på·²ç»éå†å®Œnums1äº†
                if(p == m)
                {
                    //ç”±äºnums1éå†å®Œåæ²¡æœ‰å€¼ï¼Œç›´æ¥è®©tmpæ‹¿num2å†…çš„å€¼
                    tmp = nums2[q++];
                }//ç¬¬äºŒä¸ªåˆ¤æ–­æ¡ä»¶ï¼Œä¸ä¸Šæ–¹ç›¸åŒï¼Œå‡è®¾éå†å®Œnums2
                else if(q == n)
                {
                    tmp = num1[p++];
                }//å½“ä¸¤ä¸ªæç«¯æƒ…å†µåˆ¤æ–­å®Œæ¯•åï¼Œç¬¬ä¸‰ä¸ªåˆ¤æ–­æ¡ä»¶å°±æ­£å¸¸å»åˆ¤æ–­å¤§å°
                else if(nums1[p]<nums2[q])
                {
                    tmp = nums1[p++];
                }
                else
                {
                    tmp = nums2[q++];
                }
                //åˆ¤æ–­å®Œæ¯•åä»ä¸´æ—¶å˜é‡ä¸­æ‹¿åˆ°å€¼
                //p+q-1ä¸ºsortedæ•°ç»„çš„å½“å‰ä½ç½®
                sorted[p+q-1] = tmp;
           		
            }
            //ä½¿ç”¨å¾ªç¯ è®©nums1æ‹¿åˆ°sortedæ•°ç»„çš„å€¼
            for(int i = 0; i != m + n; ++i)
            {
                nums1[i] = sorted[i];
            }
            return nums1;
        }
}


//ç®€æ´ç‰ˆæœ¬
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1=0,p2=0;
        int sorted[m+n];//åˆ›å»ºå¦å¤–ä¸€ä¸ªæ•°ç»„
        int cur = 0;
        while(p1<m||p2<n)
        {
            if(p1==m)//å½“p1å…ˆéå†å®Œ
                cur = nums2[p2++];//curå°±å»å…ˆæ‹¿nums2[p2]çš„å€¼ï¼Œç„¶å++
            else if(p2 == n)//å¦‚æœp2å…ˆéå†å®Œ
                cur = nums1[p1++];//curå°±å…ˆå»æ‹¿nums1[p1]çš„å€¼ï¼Œç„¶å++
            else if(nums1[p1]<nums2[p2])//å½“nums1[p1]çš„å€¼å°äºnums2[p2]çš„å€¼æ—¶
                cur = nums1[p1++];//curå»æ‹¿nums1[p1]çš„å€¼
            else//å½“nums1[p1]>nums2[p2]
                cur = nums2[p2++];//curæ‹¿åˆ°nums2[p2]çš„å€¼
            sorted[p1+p2-1] = cur;//ç”¨ç¬¬ä¸‰ä¸ªæ•°ç»„sorted æ‹¿åˆ°curå†…éƒ¨çš„å€¼ï¼Œä¾æ¬¡å¾ªç¯ P1+P2-1ï¼Œå› ä¸ºp1,p2æ˜¯ä¸‹æ ‡ï¼Œæ‰€ä»¥è¦-1é˜²æ­¢è¶Šç•Œè®¿é—®
        }
        for(int i = 0;i!=m+n;++i)//é€šè¿‡m+næ¬¡éå†ï¼Œè®©nums1æ•°ç»„æ‹¿åˆ°sortedæ•°ç»„å†…çš„å€¼ç„¶åreturn nums1ï¼›
        {
            nums1[i] = sorted[i];
        }
    }
};
```

[27. ç§»é™¤å…ƒç´ ](https://leetcode.cn/problems/remove-element/)

ç»™ä½ ä¸€ä¸ªæ•°ç»„ `nums` å’Œä¸€ä¸ªå€¼ `val`ï¼Œä½ éœ€è¦ **[åŸåœ°](https://baike.baidu.com/item/åŸåœ°ç®—æ³•)** ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº `val` çš„å…ƒç´ ï¼Œå¹¶è¿”å›ç§»é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚

ä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œä½ å¿…é¡»ä»…ä½¿ç”¨ `O(1)` é¢å¤–ç©ºé—´å¹¶ **[åŸåœ° ](https://baike.baidu.com/item/åŸåœ°ç®—æ³•)ä¿®æ”¹è¾“å…¥æ•°ç»„**ã€‚

å…ƒç´ çš„é¡ºåºå¯ä»¥æ”¹å˜ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚

**è¯´æ˜:**

ä¸ºä»€ä¹ˆè¿”å›æ•°å€¼æ˜¯æ•´æ•°ï¼Œä½†è¾“å‡ºçš„ç­”æ¡ˆæ˜¯æ•°ç»„å‘¢?

è¯·æ³¨æ„ï¼Œè¾“å…¥æ•°ç»„æ˜¯ä»¥**ã€Œå¼•ç”¨ã€**æ–¹å¼ä¼ é€’çš„ï¼Œè¿™æ„å‘³ç€åœ¨å‡½æ•°é‡Œä¿®æ”¹è¾“å…¥æ•°ç»„å¯¹äºè°ƒç”¨è€…æ˜¯å¯è§çš„ã€‚

ä½ å¯ä»¥æƒ³è±¡å†…éƒ¨æ“ä½œå¦‚ä¸‹:

```
// nums æ˜¯ä»¥â€œå¼•ç”¨â€æ–¹å¼ä¼ é€’çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å¯¹å®å‚ä½œä»»ä½•æ‹·è´
int len = removeElement(nums, val);

// åœ¨å‡½æ•°é‡Œä¿®æ”¹è¾“å…¥æ•°ç»„å¯¹äºè°ƒç”¨è€…æ˜¯å¯è§çš„ã€‚
// æ ¹æ®ä½ çš„å‡½æ•°è¿”å›çš„é•¿åº¦, å®ƒä¼šæ‰“å°å‡ºæ•°ç»„ä¸­ è¯¥é•¿åº¦èŒƒå›´å†… çš„æ‰€æœ‰å…ƒç´ ã€‚
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums = [3,2,2,3], val = 3
è¾“å‡ºï¼š2, nums = [2,2]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2, å¹¶ä¸” nums ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ å‡ä¸º 2ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œå‡½æ•°è¿”å›çš„æ–°é•¿åº¦ä¸º 2 ï¼Œè€Œ nums = [2,2,3,3] æˆ– nums = [2,2,0,0]ï¼Œä¹Ÿä¼šè¢«è§†ä½œæ­£ç¡®ç­”æ¡ˆã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums = [0,1,2,2,3,0,4,2], val = 2
è¾“å‡ºï¼š5, nums = [0,1,3,0,4]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5, å¹¶ä¸” nums ä¸­çš„å‰äº”ä¸ªå…ƒç´ ä¸º 0, 1, 3, 0, 4ã€‚æ³¨æ„è¿™äº”ä¸ªå…ƒç´ å¯ä¸ºä»»æ„é¡ºåºã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
```

 

**æç¤ºï¼š**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

```c++
//åŒæŒ‡é’ˆè§£æ³•
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int sz = nums.size();//æ‹¿åˆ°æ•°ç»„é•¿åº¦
        int left = 0;//è®¾ç½®ç¬¬ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘åˆå§‹ä½ç½®
        //è®¾ç½®ç¬¬äºŒä¸ªæŒ‡é’ˆæŒ‡å‘åˆå§‹ä½ç½®
        for(int right = 0;right<sz;++right)
        {
            //å‡è®¾rightæŒ‡å‘ä½ç½®çš„å€¼ä¸ç­‰äºvalï¼Œåˆ™è®©leftä½ç½®æ‹¿åˆ°rightçš„å€¼ï¼Œç„¶åè®©leftå‘å++ï¼Œæœ€åreturn leftä½ç½®
            if(nums[right]!=val)
            {
                nums[left] = nums[right];
                left++;
            }
        }
        return left;
    }
};
//åŒæŒ‡é’ˆä¼˜åŒ–è§£æ³•
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //ä¸€ä¸ªåœ¨å¤´ ä¸€ä¸ªåœ¨å°¾
        int left = 0, right = nums.size();
        //å½“å·¦è¾¹å°äºå³è¾¹æ—¶å°±è¿›å…¥å¾ªç¯ï¼Œåä¹‹ç»ˆæ­¢å¾ªç¯
        while(left<right)
        {
            //å½“leftæŒ‡å‘ä½ç½®çš„å€¼==valæ—¶ï¼Œè®©leftæŒ‡å‘ä½ç½®çš„å€¼è¢«æ•°ç»„æœ€åä¸€ä¸ªå€¼è¦†ç›–ï¼Œç„¶åè®©æ•°ç»„ï¼ˆ--ï¼‰ï¼Œå¦‚æœï¼=valå°±è®©left++ ï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ª==valçš„ä½ç½®ï¼Œä¾æ¬¡è¦†ç›–ï¼Œæœ€åreturn left
            if(nums[left] == val)
            {
                nums[left] = nums[right-1];
                right--;
            }
            else
                left++;
        }
        return left;
    }
};

//å¾ªç¯è§£æ³•
//å½“nums[i]ä½ç½®==val æ—¶ åˆ©ç”¨continueçš„ç‰¹æ€§çŸ­æš‚è·³å‡ºæ­¤ä½ç½®çš„å¾ªç¯ï¼Œç›´æ¥æ‰§è¡Œä¸‹æ¬¡å¾ªç¯ï¼Œæœ€åreturn n
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int sz = nums.size();
        int n = 0;
        for(int i = 0; i < sz;++i)
        {
            if(nums[i] == val)
                continue;
            nums[n] = nums[i];
            n++;
        }
        return n;
    }
};
```

[215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

ç»™å®šæ•´æ•°æ•°ç»„ `nums` å’Œæ•´æ•° `k`ï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ `**k**` ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

è¯·æ³¨æ„ï¼Œä½ éœ€è¦æ‰¾çš„æ˜¯æ•°ç»„æ’åºåçš„ç¬¬ `k` ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ `k` ä¸ªä¸åŒçš„å…ƒç´ ã€‚

ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: [3,2,1,5,6,4], k = 2
è¾“å‡º: 5
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: [3,2,3,1,2,4,5,5,6], k = 4
è¾“å‡º: 4
```

**æç¤ºï¼š**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

```C++
//æš´åŠ›è§£æ³•ï¼Œä¸ç¬¦åˆé¢˜ç›®ä¸­æ—¶é—´å¤æ‚åº¦çš„è¦æ±‚
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());

        return nums[nums.size()-k];
    }
};
//å †æ’ æ—¶é—´å¤æ‚åº¦ O(k*logN+N)
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(),nums.end());//O(N)
        while(--k)//K*logN
        {
            pq.pop();
        }
        return pq.top();
    }
};
//å°å †
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(),nums.begin()+k);//å»ºå°å †
        for(size_t i = k;i<nums.size();++i)
        {
            if(nums[i]>pq.top())//å¦‚æœéå†åˆ°çš„å€¼å¤§äºå½“å‰å †é¡¶å…ƒç´ ,å°±æŠŠå½“å‰å †çš„å€¼popæ‰ï¼Œå†æŠŠæ•°ç»„ä¸­çš„å€¼æ”¾è¿›æ¥
            {
                pq.pop();
                pq.push(nums[i]);
            }
        }
        return pq.top();
        
    }
};
```

[155. æœ€å°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/min-stack/)

è®¾è®¡ä¸€ä¸ªæ”¯æŒ `push` ï¼Œ`pop` ï¼Œ`top` æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚

å®ç° `MinStack` ç±»:

- `MinStack()` åˆå§‹åŒ–å †æ ˆå¯¹è±¡ã€‚
- `void push(int val)` å°†å…ƒç´ valæ¨å…¥å †æ ˆã€‚
- `void pop()` åˆ é™¤å †æ ˆé¡¶éƒ¨çš„å…ƒç´ ã€‚
- `int top()` è·å–å †æ ˆé¡¶éƒ¨çš„å…ƒç´ ã€‚
- `int getMin()` è·å–å †æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥ï¼š
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

è¾“å‡ºï¼š
[null,null,null,null,-3,null,0,-2]

è§£é‡Šï¼š
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> è¿”å› -3.
minStack.pop();
minStack.top();      --> è¿”å› 0.
minStack.getMin();   --> è¿”å› -2.
```

**æç¤ºï¼š**

- `-231 <= val <= 231 - 1`

- `pop`ã€`top` å’Œ `getMin` æ“ä½œæ€»æ˜¯åœ¨ **éç©ºæ ˆ** ä¸Šè°ƒç”¨

- `push`, `pop`, `top`, and `getMin`æœ€å¤šè¢«è°ƒç”¨ `3 * 10^4 æ¬¡

  æ€è·¯ï¼šé¦–å…ˆå®ä¾‹**st** and **minst**ä¸¤ä¸ªæ ˆï¼Œ**st**ç”¨æ¥æ­£å¸¸å­˜æ”¾pushçš„å€¼ï¼Œ**minst**ç”¨æ¥å­˜æ”¾**st**çš„**æœ€å°å€¼**

  å½“**st**æ‹¿åˆ°ç¬¬ä¸€ä¸ªå€¼æ—¶ï¼Œ**minst**é»˜è®¤æ‹¿åˆ°ç¬¬ä¸€ä¸ªå€¼ä¸ºæœ€å°å€¼ï¼Œåç»­**st**æ‹¿åˆ°çš„å€¼ä¸å‰é¢pushçš„å€¼åšå¯¹æ¯”ï¼Œå¦‚æœå°ï¼Œåˆ™pushåˆ°**minst**æ›´æ–°ï¼Œpopå€¼æ—¶ï¼Œ**minst**å°†ä¼šä¸**st**åŒæ­¥pop

  ```C++
  class MinStack{
  	public:
  		MinStack{}
  		void push(int val)
  		{
  			_st.push(val);
  			if(_minst.empty()||val<=_minst.top())]
  			{
  				_minst.push(val);
  			}
  		}
  		void pop()
  		{
  			if(_minst.top()==_st.top())
  			{
  				_minst.pop();
  			}
  			_st.pop();
  		}
  		int top()
  		{
  			return _st.top();
  		}
  		int getMin()
  		{
  			return _minst.top();
  		}
  		stack<int> _st;
  		stack<int> _minst;
  }
  ```

[æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—_ç‰›å®¢é¢˜éœ¸_ç‰›å®¢ç½‘ (nowcoder.com)](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)

## æè¿°

è¾“å…¥ä¸¤ä¸ªæ•´æ•°åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—è¡¨ç¤ºæ ˆçš„å‹å…¥é¡ºåºï¼Œè¯·åˆ¤æ–­ç¬¬äºŒä¸ªåºåˆ—æ˜¯å¦å¯èƒ½ä¸ºè¯¥æ ˆçš„å¼¹å‡ºé¡ºåºã€‚å‡è®¾å‹å…¥æ ˆçš„æ‰€æœ‰æ•°å­—å‡ä¸ç›¸ç­‰ã€‚ä¾‹å¦‚åºåˆ—1,2,3,4,5æ˜¯æŸæ ˆçš„å‹å…¥é¡ºåºï¼Œåºåˆ—4,5,3,2,1æ˜¯è¯¥å‹æ ˆåºåˆ—å¯¹åº”çš„ä¸€ä¸ªå¼¹å‡ºåºåˆ—ï¼Œä½†4,3,5,1,2å°±ä¸å¯èƒ½æ˜¯è¯¥å‹æ ˆåºåˆ—çš„å¼¹å‡ºåºåˆ—ã€‚

1. 0<=pushV.length == popV.length <=1000
2. -1000<=pushV[i]<=1000

3. pushV çš„æ‰€æœ‰æ•°å­—å‡ä¸ç›¸åŒ

## ç¤ºä¾‹1

è¾“å…¥ï¼š

```
[1,2,3,4,5],[4,5,3,2,1]
```

è¿”å›å€¼ï¼š

```
true
```

è¯´æ˜ï¼š

```
å¯ä»¥é€šè¿‡push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
è¿™æ ·çš„é¡ºåºå¾—åˆ°[4,5,3,2,1]è¿™ä¸ªåºåˆ—ï¼Œè¿”å›true      
```

## ç¤ºä¾‹2

è¾“å…¥ï¼š

```
[1,2,3,4,5],[4,3,5,1,2]
```

è¿”å›å€¼ï¼š

```
false
```

è¯´æ˜ï¼š

```
ç”±äºæ˜¯[1,2,3,4,5]çš„å‹å…¥é¡ºåºï¼Œ[4,3,5,1,2]çš„å¼¹å‡ºé¡ºåºï¼Œè¦æ±‚4ï¼Œ3ï¼Œ5å¿…é¡»åœ¨1ï¼Œ2å‰å‹å…¥ï¼Œä¸”1ï¼Œ2ä¸èƒ½å¼¹å‡ºï¼Œä½†æ˜¯è¿™æ ·å‹å…¥çš„é¡ºåºï¼Œ1åˆä¸èƒ½åœ¨2ä¹‹å‰å¼¹å‡ºï¼Œæ‰€ä»¥æ— æ³•å½¢æˆçš„ï¼Œè¿”å›false
```

æ€è·¯ï¼š

```C++
class Solution{
    public:
     /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * 
     * @param pushV intæ•´å‹vector 
     * @param popV intæ•´å‹vector 
     * @return boolå¸ƒå°”å‹
     */
    bool IsPopOrder(vector<int>& pushV, vector<int>& popV) {
        int pushi = 0,popi = 0;
        stack<int> st;
        while(pushi < pushV.size())
        {
            st.push(pushV[pushi++]);
            while(!st.empty()&&st.top() == popV[popi])
            {
                ++popi;
                st.pop();
            }
        }
        return st.empty();
    }
}
```

[150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `tokens` ï¼Œè¡¨ç¤ºä¸€ä¸ªæ ¹æ® [é€†æ³¢å…°è¡¨ç¤ºæ³•](https://baike.baidu.com/item/é€†æ³¢å…°å¼/128437) è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚

è¯·ä½ è®¡ç®—è¯¥è¡¨è¾¾å¼ã€‚è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¡¨è¾¾å¼å€¼çš„æ•´æ•°ã€‚

**æ³¨æ„ï¼š**

- æœ‰æ•ˆçš„ç®—ç¬¦ä¸º `'+'`ã€`'-'`ã€`'*'` å’Œ `'/'` ã€‚
- æ¯ä¸ªæ“ä½œæ•°ï¼ˆè¿ç®—å¯¹è±¡ï¼‰éƒ½å¯ä»¥æ˜¯ä¸€ä¸ªæ•´æ•°æˆ–è€…å¦ä¸€ä¸ªè¡¨è¾¾å¼ã€‚
- ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„é™¤æ³•æ€»æ˜¯ **å‘é›¶æˆªæ–­** ã€‚
- è¡¨è¾¾å¼ä¸­ä¸å«é™¤é›¶è¿ç®—ã€‚
- è¾“å…¥æ˜¯ä¸€ä¸ªæ ¹æ®é€†æ³¢å…°è¡¨ç¤ºæ³•è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚
- ç­”æ¡ˆåŠæ‰€æœ‰ä¸­é—´è®¡ç®—ç»“æœå¯ä»¥ç”¨ **32 ä½** æ•´æ•°è¡¨ç¤ºã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼štokens = ["2","1","+","3","*"]
è¾“å‡ºï¼š9
è§£é‡Šï¼šè¯¥ç®—å¼è½¬åŒ–ä¸ºå¸¸è§çš„ä¸­ç¼€ç®—æœ¯è¡¨è¾¾å¼ä¸ºï¼š((2 + 1) * 3) = 9
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼štokens = ["4","13","5","/","+"]
è¾“å‡ºï¼š6
è§£é‡Šï¼šè¯¥ç®—å¼è½¬åŒ–ä¸ºå¸¸è§çš„ä¸­ç¼€ç®—æœ¯è¡¨è¾¾å¼ä¸ºï¼š(4 + (13 / 5)) = 6
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼štokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
è¾“å‡ºï¼š22
è§£é‡Šï¼šè¯¥ç®—å¼è½¬åŒ–ä¸ºå¸¸è§çš„ä¸­ç¼€ç®—æœ¯è¡¨è¾¾å¼ä¸ºï¼š
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**æç¤ºï¼š**

- `1 <= tokens.length <= 104`
- `tokens[i]` æ˜¯ä¸€ä¸ªç®—ç¬¦ï¼ˆ`"+"`ã€`"-"`ã€`"*"` æˆ– `"/"`ï¼‰ï¼Œæˆ–æ˜¯åœ¨èŒƒå›´ `[-200, 200]` å†…çš„ä¸€ä¸ªæ•´æ•°

**é€†æ³¢å…°è¡¨è¾¾å¼ï¼š**

é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯ä¸€ç§åç¼€è¡¨è¾¾å¼ï¼Œæ‰€è°“åç¼€å°±æ˜¯æŒ‡ç®—ç¬¦å†™åœ¨åé¢ã€‚

- å¹³å¸¸ä½¿ç”¨çš„ç®—å¼åˆ™æ˜¯ä¸€ç§ä¸­ç¼€è¡¨è¾¾å¼ï¼Œå¦‚ `( 1 + 2 ) * ( 3 + 4 )` ã€‚
- è¯¥ç®—å¼çš„é€†æ³¢å…°è¡¨è¾¾å¼å†™æ³•ä¸º `( ( 1 2 + ) ( 3 4 + ) * )` ã€‚

é€†æ³¢å…°è¡¨è¾¾å¼ä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ä¸ªä¼˜ç‚¹ï¼š

- å»æ‰æ‹¬å·åè¡¨è¾¾å¼æ— æ­§ä¹‰ï¼Œä¸Šå¼å³ä¾¿å†™æˆ `1 2 + 3 4 + * `ä¹Ÿå¯ä»¥ä¾æ®æ¬¡åºè®¡ç®—å‡ºæ­£ç¡®ç»“æœã€‚
- é€‚åˆç”¨æ ˆæ“ä½œè¿ç®—ï¼šé‡åˆ°æ•°å­—åˆ™å…¥æ ˆï¼›é‡åˆ°ç®—ç¬¦åˆ™å–å‡ºæ ˆé¡¶ä¸¤ä¸ªæ•°å­—è¿›è¡Œè®¡ç®—ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆä¸­

æ€è·¯ï¼šã€‚ã€‚ã€‚ã€‚ã€‚

```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        set<string> s = {"+","-","*","/"};
        for(auto& str : tokens)
        {
            //1.æ“ä½œæ•°å…¥æ ˆï¼Œæ“ä½œç¬¦è¿ç®—
            if(s.find(str)!=s.end())
            {
                //æ“ä½œç¬¦
                int right = st.top();
                st.pop();
                int left = st.top();
                st.pop();
                switch(str[0])
                {
                    case '+':
                        st.push(left+right);
                        break;
                    case '-':
                        st.push(left-right);
                        break;
                    case '*':
                        st.push(left*right);
                        break;
                    case '/':
                        st.push(left/right);
                        break;

                }
            }
            else
            {
                st.push(stoi(str));
            }
        }
        return st.top();
    }
};
```



[606. æ ¹æ®äºŒå‰æ ‘åˆ›å»ºå­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/construct-string-from-binary-tree/description/)

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¯·ä½ é‡‡ç”¨å‰åºéå†çš„æ–¹å¼ï¼Œå°†äºŒå‰æ ‘è½¬åŒ–ä¸ºä¸€ä¸ªç”±æ‹¬å·å’Œæ•´æ•°ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ„é€ å‡ºçš„å­—ç¬¦ä¸²ã€‚

ç©ºèŠ‚ç‚¹ä½¿ç”¨ä¸€å¯¹ç©ºæ‹¬å·å¯¹ `"()"` è¡¨ç¤ºï¼Œè½¬åŒ–åéœ€è¦çœç•¥æ‰€æœ‰ä¸å½±å“å­—ç¬¦ä¸²ä¸åŸå§‹äºŒå‰æ ‘ä¹‹é—´çš„ä¸€å¯¹ä¸€æ˜ å°„å…³ç³»çš„ç©ºæ‹¬å·å¯¹ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg)

```
è¾“å…¥ï¼šroot = [1,2,3,4]
è¾“å‡ºï¼š"1(2(4))(3)"
è§£é‡Šï¼šåˆæ­¥è½¬åŒ–åå¾—åˆ° "1(2(4)())(3()())" ï¼Œä½†çœç•¥æ‰€æœ‰ä¸å¿…è¦çš„ç©ºæ‹¬å·å¯¹åï¼Œå­—ç¬¦ä¸²åº”è¯¥æ˜¯"1(2(4))(3)" ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg)

```
è¾“å…¥ï¼šroot = [1,2,3,null,4]
è¾“å‡ºï¼š"1(2()(4))(3)"
è§£é‡Šï¼šå’Œç¬¬ä¸€ä¸ªç¤ºä¾‹ç±»ä¼¼ï¼Œä½†æ˜¯æ— æ³•çœç•¥ç¬¬ä¸€ä¸ªç©ºæ‹¬å·å¯¹ï¼Œå¦åˆ™ä¼šç ´åè¾“å…¥ä¸è¾“å‡ºä¸€ä¸€æ˜ å°„çš„å…³ç³»ã€‚
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ `[1, 104]`
- `-1000 <= Node.val <= 1000`

æ€è·¯ï¼š

1.å·¦å³ä¸ºç©ºå¯ä»¥çœç•¥æ‹¬å·

2.å³ä¸ºç©ºçœç•¥æ‹¬å·

3.å·¦ä¸ºç©ºï¼Œä¸èƒ½çœç•¥æ‹¬å·ï¼Œæ— æ³•è·Ÿå³ä¸ºç©ºåŒºåˆ†

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    string tree2str(TreeNode* root) {
		string str;//åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„æ‹¿ç€æ‹¬å·å’Œå€¼è¿”å›
        if(root==nullptr)
        	return str;
        str += to_string(root->val);//è½¬ç±»å‹ï¼Œint->string
            
        if(root->left || root->right)
        {
            str += '(';
            str += tree2str(root->left);
            str += ')'
        }
        if(root->right)
        {
            str += '(';
            str += tree2str(root->right);
            str += ')';
        }
        return str;
    }
};
```

[102. äºŒå‰æ ‘çš„å±‚åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-1000 <= Node.val <= 1000`

è§£æ³• é˜Ÿåˆ—ï¼Œç”¨å˜é‡æ§åˆ¶ä¸€å±‚çš„ä¸ªæ•°ï¼Œå‡ºå®Œä¸€å±‚å†å‡ºä¸‹ä¸€å±‚

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

    }
};
```

[236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

[ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/æœ€è¿‘å…¬å…±ç¥–å…ˆ/8918834?fr=aladdin)ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆ**ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆ**ï¼‰ã€‚â€

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
è¾“å‡ºï¼š3
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
è¾“å‡ºï¼š5
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5 ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1,2], p = 1, q = 2
è¾“å‡ºï¼š1
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[2, 105]` å†…ã€‚
- `-109 <= Node.val <= 109`
- æ‰€æœ‰ `Node.val` `äº’ä¸ç›¸åŒ` ã€‚
- `p != q`
- `p` å’Œ `q` å‡å­˜åœ¨äºç»™å®šçš„äºŒå‰æ ‘ä¸­ã€‚

**æ€è·¯ï¼š**

**1.æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰parentï¼ˆä¸‰å‰é“¾ï¼‰->é“¾è¡¨ç›¸äº¤**

**2.æ™®é€šäºŒå‰æ ‘ï¼Œè§„å¾‹ï¼špå’Œqåˆ†åˆ«åœ¨å·¦å³ï¼Œå½“å‰èŠ‚ç‚¹å°±æ˜¯å…¬å…±ç¥–å…ˆ or å…¶ä¸­ä¸€ä¸ªå°±æ˜¯å½“å‰æ ‘çš„æ ¹**

![image-20240420110122210](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240420110122210.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isTree(TreeNode* root,TreeNode* x)
    {
        if(root == nullptr)
            return false;
        if(root == x)
            return true;
        return isTree(root->left,x)
        || isTree(root->right,x);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p||root==q)
       		return root;
        bool pInLeft = isTree(root->left,p);//ä¸åœ¨å·¦è¾¹å°±åœ¨å³è¾¹
        bool pInRight = !pInLeft;//ç›´æ¥å¤ç”¨
        
        bool pInLeft = isTree(root->left,q);//ä¸åœ¨å·¦è¾¹å°±åœ¨å³è¾¹
        bool pInRight = !pInLeft;//ç›´æ¥å¤ç”¨
        
        //ä¸€ä¸ªåœ¨å·¦ä¸€ä¸ªåœ¨å³
        if((pInLeft&&qInRight)||(qInLeft&&pInRight))
            return root;
        //éƒ½åœ¨å·¦
        if(pInLeft && qInLeft)
            return lowestCommonAncestor(root->left,p,q);
        //éƒ½åœ¨å³
        if(pInRight && qInRight)
            return lowestCommonAncestor(root->right,p,q);
        
        return nullptr;
    }
};
```

ç¬¬äºŒç§è§£æ³•ï¼š

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool FindPath(TreeNode* root,TreeNode* x,stack<TreeNode*>& path)
    {
        if(root == nullptr)
            return false;
        path.push(root);
        if(root == x)
            return true;
        if(FindPath(root->left,x,path))
   		   return true;
        if(FindPath(root->right,x,path))
   		   return true;
        //æ²¡æ‰¾åˆ°popæ‰ï¼Œç„¶åè¿”å›ç»™ä¸Šä¸€å±‚false
        path.pop();
        return false;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        stack<TreeNode*> pPath,qPath;
        FindPath(root,p,pPath);
        FindPath(root,q,qPath);
        //ç±»ä¼¼æ‰¾ç›¸äº¤èŠ‚ç‚¹å°±æ˜¯å…¬å…±ç¥–å…ˆ
        while(pPath.size()!=qPath.size())
        {
            if(pPath.size()>qPath.size())
                pPath.pop();
            else
                qPath.pop();
        }
        while(pPath.top()!=qPath.top())
        {
            pPath.pop();
            qPath.pop();
        }
        
        //å½“topç›¸ç­‰æ—¶è¿”å›è°éƒ½æ˜¯ä¸€æ ·çš„
        return pPath.top();
    }
};
```



[[NOIP2010\]æ•°å­—ç»Ÿè®¡_ç‰›å®¢é¢˜éœ¸_ç‰›å®¢ç½‘ (nowcoder.com)](https://www.nowcoder.com/practice/179d9754eeaf48a1b9a49dc1d438525a?tpId=290&tqId=39941&ru=/exam/oj)

![image-20240419112315701](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240419112315701.png)

è§£æ³•ï¼šæšä¸¾+æ•°å­—æ‹†åˆ†

```C++
#include <iostream>
using namespace std;

int main() {
   int l,r;
   cin>>l>>r;
    int ret = 0;
    for(int i = l,i<=r;++i)
    {
        int tmp = i;
        while(tmp)
        {
            if(tmp&10==2)ret++;
            tmp/=10;
        }
    }
    cout<<ret<<endl;
}

```

[ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†_ç‰›å®¢é¢˜éœ¸_ç‰›å®¢ç½‘ (nowcoder.com)](https://www.nowcoder.com/practice/56ea71d1f4e94de2aaec10e985874cce?tpId=196&tqId=40269&ru=/exam/oj)

![image-20240419113245507](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240419113245507.png)

è§£æ³•ï¼šå“ˆå¸Œ---ç›´æ¥ç”¨å®¹å™¨è¾ƒéš¾

å»ºè®®ä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿå“ˆå¸Œ bool hash[1010]

![image-20240419114159246](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240419114159246.png)

```C++
class Solution {
    bool hashp[1010] = {0};//ç‰›å®¢å†…éƒ¨ä¸åˆå§‹åŒ–å°±æ˜¯éšæœºå€¼ï¼Œleetcodeæ˜¯0
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * 
     * @param nums1 intæ•´å‹vector 
     * @param nums2 intæ•´å‹vector 
     * @return intæ•´å‹vector
     */
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        // write code here
        vector<int> ret;
        for(auto i:nums1)
        {
            hash[i] = true;
        }
        for(auto i:nums2)
        {
            if(hash[i])//å¦‚æœåœ¨å“ˆå¸Œè¡¨ä¸­
            {
                ret.push_back(i);//pushè¿›å»retæ•°ç»„
                hash[x] = false;
            }
        }
        return ret;
    }
};
```

[ç‚¹å‡»æ¶ˆé™¤_ç‰›å®¢é¢˜éœ¸_ç‰›å®¢ç½‘ (nowcoder.com)](https://www.nowcoder.com/practice/8d3643ec29654cf8908b5cf3a0479fd5)

![image-20240419114809181](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240419114809181.png)

ç±»ä¼¼äºæ‹¬å·åŒ¹é…é¢˜

è§£æ³•ï¼šæ ˆ---æ³¨æ„ï¼šæ”¾åˆ°æ ˆä¸­å†popå‡ºæ¥æ˜¯ä¸€ä¸ªé€†åºè¿‡æ¥çš„

ç»†èŠ‚:ç”¨å¯å˜é•¿çš„æ•°ç»„ï¼Œæ¥æ¨¡æ‹Ÿæ ˆç»“æ„

```c++
#include <iostream>
using namespace std;

int main() {
    
}
// 64 ä½è¾“å‡ºè¯·ç”¨ printf("%lld")
```

[äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨_ç‰›å®¢é¢˜éœ¸_ç‰›å®¢ç½‘ (nowcoder.com)](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&ru=/exam/oj)

è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„åŒå‘é“¾è¡¨ã€‚å¦‚ä¸‹å›¾æ‰€ç¤º

![img](https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2)

æ•°æ®èŒƒå›´ï¼šè¾“å…¥äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•° 0â‰¤ğ‘›â‰¤10000â‰¤*n*â‰¤1000ï¼ŒäºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ 0â‰¤ğ‘£ğ‘ğ‘™â‰¤10000â‰¤*v**a**l*â‰¤1000
è¦æ±‚ï¼šç©ºé—´å¤æ‚åº¦ğ‘‚(1)*O*(1)ï¼ˆå³åœ¨åŸæ ‘ä¸Šæ“ä½œï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ ğ‘‚(ğ‘›)*O*(*n*)

æ³¨æ„:

1.è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„ç»“ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­ç»“ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚å½“è½¬åŒ–å®Œæˆä»¥åï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆéœ€è¦æŒ‡å‘åç»§
2.è¿”å›é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
3.å‡½æ•°è¿”å›çš„TreeNodeï¼Œæœ‰å·¦å³æŒ‡é’ˆï¼Œå…¶å®å¯ä»¥çœ‹æˆä¸€ä¸ªåŒå‘é“¾è¡¨çš„æ•°æ®ç»“æ„

4.ä½ ä¸ç”¨è¾“å‡ºåŒå‘é“¾è¡¨ï¼Œç¨‹åºä¼šæ ¹æ®ä½ çš„è¿”å›å€¼è‡ªåŠ¨æ‰“å°è¾“å‡º

### è¾“å…¥æè¿°ï¼š

äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹

### è¿”å›å€¼æè¿°ï¼š

åŒå‘é“¾è¡¨çš„å…¶ä¸­ä¸€ä¸ªå¤´èŠ‚ç‚¹ã€‚

## ç¤ºä¾‹1

è¾“å…¥ï¼š

```
{10,6,14,4,8,12,16}
```

å¤åˆ¶

è¿”å›å€¼ï¼š

```
From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
```

å¤åˆ¶

è¯´æ˜ï¼š

```
è¾“å…¥é¢˜é¢å›¾ä¸­äºŒå‰æ ‘ï¼Œè¾“å‡ºçš„æ—¶å€™å°†åŒå‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹è¿”å›å³å¯ã€‚     
```

## ç¤ºä¾‹2

è¾“å…¥ï¼š

```
{5,4,#,3,#,2,#,1}
```

å¤åˆ¶

è¿”å›å€¼ï¼š

```
From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
```

å¤åˆ¶

è¯´æ˜ï¼š

```
                    5
                  /
                4
              /
            3
          /
        2
      /
    1
æ ‘çš„å½¢çŠ¶å¦‚ä¸Šå›¾
```

```C++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
					//prev å¿…é¡»ç»™å¼•ç”¨ï¼Œé“¾æ¥æ˜¯åœ¨å‰ä¸€ä½å¤„ç†
					//å¼•ç”¨çš„æ˜¯æŒ‡é’ˆå˜é‡ï¼Œåªä¸è¿‡æŒ‡é’ˆçš„å€¼åˆå§‹ä¸ºnull
	void InOrderConvert(TreeNode* cur,TreeNode*& prev)
	{
		if(cur == nullptr)
			return;
		InOrderConvert(cur->left, prev);
		//ä¸­åº
		//å½“å‰ç‚¹çš„å·¦æŒ‡å‘å‰ä¸€ä¸ª
		cur->left = prev;
		if(prev)
			prev->right = cur;//å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å³æŒ‡å‘å½“å‰ç‚¹
			
		prev = cur;
		
		InOrderConvert(cur->right, prev);
	}
    TreeNode* Convert(TreeNode* pRootOfTree) {
        TreeNode* cur = pRootOfTree,*prev = nullptr;
		InOrderConvert(cur, prev);

		TreeNode* head = pRootOfTree;
		while(head && head->left)
		{
			head=head->left;
		}
		return head;
    }
};

```

[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `preorder` å’Œ `inorder` ï¼Œå…¶ä¸­ `preorder` æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†**ï¼Œ `inorder` æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†**ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
è¾“å…¥: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
è¾“å‡º: [3,9,20,null,null,15,7]
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: preorder = [-1], inorder = [-1]
è¾“å‡º: [-1]
```

**æç¤º:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` å’Œ `inorder` å‡ **æ— é‡å¤** å…ƒç´ 
- `inorder` å‡å‡ºç°åœ¨ `preorder`
- `preorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—
- `inorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—

æ€è·¯ï¼šå…ˆç¡®å®šæ ¹ï¼Œåˆ†å‰²å·¦å³å­æ ‘ä¸­åºåŒºé—´

æœ¬è´¨---å‰åºç¡®å®šæ ¹ï¼Œä¸­åºç¡®å®šå·¦å³å­æ ‘ 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
TreeNode* _build(vector<int>& preorder,vector<int>& inorder,int& previ,int inbegin,int inend)
    {
        if(inbegin>inend)
            return nullptr;
    //å¯»æ‰¾æ ¹çš„ä½ç½®
        int rooti = inbegin;
        while(rooti <= inend)
        {
            if(preorder[previ]==inorder[rooti])
            {
                break;
            }
            ++rooti;
        }
        //å‰åºç¡®å®šæ ¹
        TreeNode* root = new TreeNode(preorder[previ++]);
        //[inbegin,rooti-1] rooti [rooti+1,inend]
        //ä¸­åºåˆ†å‰²ç¡®å®šå·¦å³å­æ ‘
        root->left =_build(preorder,inorder,previ,inbegin,rooti-1);
        root->right = _build(preorder,inorder,previ,rooti+1,inend);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int i = 0;
        TreeNode* root = _build(preorder,inorder,i,0,inorder.size()-1);
        return root;
    }
};
```

[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder` å’Œ `postorder` ï¼Œå…¶ä¸­ `inorder` æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder` æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— *äºŒå‰æ ‘* ã€‚

**ç¤ºä¾‹ 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
è¾“å…¥ï¼šinorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
è¾“å‡ºï¼š[3,9,20,null,null,15,7]
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥ï¼šinorder = [-1], postorder = [-1]
è¾“å‡ºï¼š[-1]
```

**æç¤º:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` å’Œ `postorder` éƒ½ç”± **ä¸åŒ** çš„å€¼ç»„æˆ
- `postorder` ä¸­æ¯ä¸€ä¸ªå€¼éƒ½åœ¨ `inorder` ä¸­
- `inorder` **ä¿è¯**æ˜¯æ ‘çš„ä¸­åºéå†
- `postorder` **ä¿è¯**æ˜¯æ ‘çš„ååºéå†

```C++

```

[144. äºŒå‰æ ‘çš„å‰åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ **å‰åº** éå†ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,2,3]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

**ç¤ºä¾‹ 4ï¼š**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
è¾“å…¥ï¼šroot = [1,2]
è¾“å‡ºï¼š[1,2]
```

**ç¤ºä¾‹ 5ï¼š**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2]
è¾“å‡ºï¼š[1,2]
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶ï¼š**é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ



```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> s;
        vector<int> v;
        //å·¦è·¯èŠ‚ç‚¹
        //å·¦è·¯èŠ‚ç‚¹çš„å³å­æ ‘
        TreeNode* cur = _root;
        while(cur || !s.empty())
        {
            //å…ˆè®¿é—®å·¦è·¯èŠ‚ç‚¹
            while(cur)
            {
                //å·¦è·¯èŠ‚ç‚¹è®¿é—®ä¸”å…¥æ ˆ					//æ ˆé‡Œé¢çš„èŠ‚ç‚¹è¡¨ç¤ºä¾æ¬¡è®¿é—®è¿™äº›èŠ‚ç‚¹çš„å³å­æ ‘
                v.push_back(cur->val);
                s.push(cur);
                cur = cur->left;
            }
            //å­é—®é¢˜æ–¹å¼è®¿é—®å·¦è·¯èŠ‚ç‚¹çš„å³å­æ ‘
            TreeNode* top = s.top();
            s.pop();

            cur = top->right;
        }
        return v;
    }
};
```

![image-20240422202704565](C:\Users\XL\AppData\Roaming\Typora\typora-user-images\image-20240422202704565.png)

[94. äºŒå‰æ ‘çš„ä¸­åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› *å®ƒçš„ **ä¸­åº** éå†* ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,3,2]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶:** é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

æ€è·¯ï¼š

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> s;
        vector<int> v;
                //å·¦è·¯èŠ‚ç‚¹
                //å·¦è·¯èŠ‚ç‚¹çš„å³å­æ ‘
                TreeNode* cur = root;
                while(cur || !s.empty())
                {
                    //å…ˆè®¿é—®å·¦è·¯èŠ‚ç‚¹
                    while(cur)
                    {                        
                        s.push(cur);
                        cur = cur->left;
                    }
                    //å­é—®é¢˜æ–¹å¼è®¿é—®å·¦è·¯èŠ‚ç‚¹çš„å³å­æ ‘
                    TreeNode* top = s.top();
                    s.pop();
                    v.push_back(top->val);

                    cur = top->right;
                }
                return v;
    }
};
```

[145. äºŒå‰æ ‘çš„ååºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **ååºéå†** ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[3,2,1]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`

**è¿›é˜¶ï¼š**é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

ååºï¼šå·¦å­æ ‘ï¼Œå³å­æ ‘ï¼Œæ ¹

ä»æ ˆä¸­å–åˆ°èŠ‚ç‚¹å°±ä»£è¡¨è®¿é—®å®Œäº†

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        TreeNode* cur = root;
        stack<TreeNode*> s;
        vector<int> v;
        TreeNode* prev =nullptr;
        while(cur||!s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur=cur->left;
            }
            TreeNode* top = s.top();
            //topèŠ‚ç‚¹çš„å³ä¸ºç©º æˆ–è€…ä¸Šä¸€ä¸ªè®¿é—®èŠ‚ç‚¹ç­‰äºå®ƒçš„å³å­©å­
            //é‚£ä¹ˆè¯´æ˜(ç©º)ä¸ç”¨è®¿é—®æˆ–è€…(ä¸ä¸ºç©º)å³å­æ ‘å·²ç»è®¿é—®è¿‡äº†
            if(top->right == nullptr || top->right == prev)
            {
                s.pop();
                v.push_back(top->val);
                prev = top;
            }
            else
            {
                //å³å­æ ‘ä¸ä¸ºç©ºï¼Œä¸”æ²¡æœ‰è®¿é—®ï¼Œå­é—®é¢˜è®¿é—®å³å­æ ‘
                cur=top->right;
            }
        }
        return v;
    }
};
```

